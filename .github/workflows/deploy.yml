name: Deploy to ECS (Terraform + ECR)

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: us-west-1
      SERVICE_NAME: ${{ github.event.repository.name }}
      ENVIRONMENT: dev
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::269599744150:role/GitHubActionsOIDC
          role-session-name: github-actions
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Ensure Terraform backend (S3 + DynamoDB) exist
        working-directory: terraform
        run: |
          set -e

          DEFAULT_BUCKET="backstage-tfstate-bucket"
          FALLBACK_BUCKET="${DEFAULT_BUCKET}-${GITHUB_REPOSITORY//\//-}-${GITHUB_SHA:0:7}"
          TF_BUCKET="$DEFAULT_BUCKET"

          echo "Checking if default S3 bucket '$DEFAULT_BUCKET' exists..."

          if ! aws s3api head-bucket --bucket "$DEFAULT_BUCKET" 2>/dev/null; then
            echo "Creating default S3 bucket..."
            aws s3api create-bucket \
              --bucket "$DEFAULT_BUCKET" \
              --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION"
          else
            echo "Default bucket exists, creating a unique fallback bucket..."
            aws s3api create-bucket \
              --bucket "$FALLBACK_BUCKET" \
              --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION" || true
            TF_BUCKET="$FALLBACK_BUCKET"
            echo "Using fallback S3 bucket: $TF_BUCKET"
          fi

          echo "TF_BUCKET=$TF_BUCKET" >> "$GITHUB_ENV"

          # Create DynamoDB table (lock table)
          LOCK_TABLE="backstage-tf-locks"
          if ! aws dynamodb describe-table --table-name "$LOCK_TABLE" 2>/dev/null; then
            echo "Creating DynamoDB lock table..."
            aws dynamodb create-table \
              --table-name "$LOCK_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "DynamoDB lock table already exists"
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Terraform init (S3 backend)
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_BUCKET }}" \
            -backend-config="key=${{ env.SERVICE_NAME }}/${{ env.ENVIRONMENT }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=backstage-tf-locks" \
            -backend-config="encrypt=true"

      - name: Terraform apply (create ECR repo first)
        working-directory: terraform
        run: |
          terraform apply -auto-approve \
            -target=module.app_service.aws_ecr_repository.this \
            -var="service_name=${{ env.SERVICE_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="region=${{ env.AWS_REGION }}"

      - name: Fetch ECR repository URL
        id: tfout
        working-directory: terraform
        run: |
          echo "ecr_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_URL: ${{ steps.tfout.outputs.ecr_url }}
        run: |
          IMAGE_URI="${ECR_URL}:${{ env.IMAGE_TAG }}"
          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"

      - name: Terraform apply (deploy service)
        working-directory: terraform
        run: |
          terraform apply -auto-approve \
            -var="service_name=${{ env.SERVICE_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="region=${{ env.AWS_REGION }}" \
            -var="image_tag=${{ env.IMAGE_TAG }}"

      - name: Output service URL
        working-directory: terraform
        run: |
          echo "Service URL: $(terraform output -raw service_url)"